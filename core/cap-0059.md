## Preamble

```
CAP: 0059
Title: Host functions for BLS12-381
Working Group:
    Owner: Jay Geng <@jayz22>
    Authors: Jay Geng <@jayz22>
    Consulted: TBD
Status: Draft
Created: 2024-08-15
Discussion: https://github.com/stellar/stellar-protocol/discussions/1500
Protocol version: 22
```

## Simple Summary
BLS12-381 is a pairing-friendly elliptic curve which enables a new suite of applications. This CAP proposes a set of new host functions providing access to BLS12-381 curve operations.

## Working Group

As described in the preamble section.

## Motivation
Pairing friendly elliptic curve operations are the backbone of many advanced Zero Knowledge (ZK) constructions such as as zkSNARKs, zkSTARKs, PLONK, BLS Signatures and more. These, in turn, enable a wide array of applications ranging from scaling, to identity management and privacy. BLS12-381 is one of the most well-known and widely adopted pairing friendly curves, due to its efficiency and 128-bit security. However, the curve operations are inherently computationally intensive, making them prohibitive to be implemented in a smart contract. Providing an efficient implementation for a well-chosen set of curve and field operations natively inside the Soroban host is crucial for unlocking privacy-preserving applications in smart contracts.

### Goals Alignment
This CAP is aligned with the following Stellar Network Goals:

  - The Stellar Network should make it easy for developers of Stellar projects
    to create highly usable products

## Abstract
11 new host functions are proposed for performing field and curve operations on BLS12-381. Definitions and the semantics of each new host function, as well as the associated new metering parameters, will be introduced and explained. 

## Specification

### New host functions
```
{
    "export": "4",
    "name": "bls12_381_g1_add",
    "args": [
        {
            "name": "point1",
            "type": "BytesObject"
        },
        {
            "name": "point2",
            "type": "BytesObject"
        }
    ],
    "return": "BytesObject",
    "docs": "Adds two BLS12-381 G1 points given in bytes format and returns the resulting G1 point in bytes format.",
    "min_supported_protocol": 22
},
{
    "export": "5",
    "name": "bls12_381_g1_mul",
    "args": [
        {
            "name": "point",
            "type": "BytesObject"
        },
        {
            "name": "scalar",
            "type": "U256Object"
        }
    ],
    "return": "BytesObject",
    "docs": "Multiplies a BLS12-381 G1 point by a scalar, and returns the resulting G1 point in bytes format.",
    "min_supported_protocol": 22
},
{
    "export": "6",
    "name": "bls12_381_g1_msm",
    "args": [
        {
            "name": "vp",
            "type": "VecObject"
        },
        {
            "name": "vs",
            "type": "VecObject"
        }
    ],
    "return": "BytesObject",
    "docs": "Performs multi-scalar-multiplication (inner product) on a vector of BLS12-381 G1 points by a vector of scalars (each being a `U256Object`), and returns the resulting G1 point in bytes format.",
    "min_supported_protocol": 22
},
{
    "export": "7",
    "name": "bls12_381_map_fp_to_g1",
    "args": [
        {
            "name": "fp",
            "type": "BytesObject"
        }
    ],
    "return": "BytesObject",
    "docs": "Maps a BLS12-381 field element to G1 point.",
    "min_supported_protocol": 22
},
{
    "export": "8",
    "name": "bls12_381_hash_to_g1",
    "args": [
        {
            "name": "msg",
            "type": "BytesObject"
        }
    ],
    "return": "BytesObject",
    "docs": "Hashes a message to a BLS12-381 G1 point given in bytes format and returns the resulting G1 point in bytes format.",
    "min_supported_protocol": 22
},
{
    "export": "9",
    "name": "bls12_381_g2_add",
    "args": [
        {
            "name": "point1",
            "type": "BytesObject"
        },
        {
            "name": "point2",
            "type": "BytesObject"
        }
    ],
    "return": "BytesObject",
    "docs": "Adds two BLS12-381 G2 points given in bytes format and returns the resulting G2 point in bytes format.",
    "min_supported_protocol": 22
},
{
    "export": "a",
    "name": "bls12_381_g2_mul",
    "args": [
        {
            "name": "point",
            "type": "BytesObject"
        },
        {
            "name": "scalar",
            "type": "U256Object"
        }
    ],
    "return": "BytesObject",
    "docs": "Multiplies a BLS12-381 G2 point by a scalar, and returns the resulting G2 point in bytes format.",
    "min_supported_protocol": 22
},
{
    "export": "b",
    "name": "bls12_381_g2_msm",
    "args": [
        {
            "name": "vp",
            "type": "VecObject"
        },
        {
            "name": "vs",
            "type": "VecObject"
        }
    ],
    "return": "BytesObject",
    "docs": "Performs multi-scalar-multiplication (inner product) on a BLS12-381 G2 point by a vector of scalars (each being a `U256Object`), and returns the resulting G2 point in bytes format.",
    "min_supported_protocol": 22
},
{
    "export": "c",
    "name": "bls12_381_map_fp2_to_g2",
    "args": [
        {
            "name": "fp2",
            "type": "BytesObject"
        }
    ],
    "return": "BytesObject",
    "docs": "Maps a BLS12-381 field element to G2 point.",
    "min_supported_protocol": 22
},
{
    "export": "d",
    "name": "bls12_381_hash_to_g2",
    "args": [
        {
            "name": "msg",
            "type": "BytesObject"
        }
    ],
    "return": "BytesObject",
    "docs": "Hashes a message to a BLS12-381 G2 point given in bytes format and returns the resulting G2 point in bytes format.",
    "min_supported_protocol": 22
},
{
    "export": "e",
    "name": "bls12_381_pairing",
    "args": [
        {
            "name": "p1",
            "type": "BytesObject"
        },
        {
            "name": "p2",
            "type": "BytesObject"
        }
    ],
    "return": "BytesObject",
    "docs": "Performs pairing operation on a BLS12-381 G1 point and a G2 point, both given in bytes format, and returns the resulting pairing in bytes format.",
    "min_supported_protocol": 22
}
```

### XDR changes

```
diff --git a/Stellar-contract-config-setting.x b/Stellar-contract-config-setting.x
index 52cc022..2664a08 100644
--- a/Stellar-contract-config-setting.x
+++ b/Stellar-contract-config-setting.x
@@ -188,7 +188,48 @@ enum ContractCostType {
     // point on a 256-bit elliptic curve
     Sec1DecodePointUncompressed = 43,
     // Cost of verifying an ECDSA Secp256r1 signature
-    VerifyEcdsaSecp256r1Sig = 44
+    VerifyEcdsaSecp256r1Sig = 44,
+
+    // Cost of deserializing an uncompressed BLS12-381 G1 point (Affine)
+    Bls12381G1AffineDeserializeUncompressed = 45,
+    // Cost of serializing a BLS12-381 G1 point (Affine) into uncompressed form
+    Bls12381G1AffineSerializeUncompressed = 46,
+    // Cost of deserializing an uncompressed BLS12-381 G2 point (Affine)
+    Bls12381G2AffineDeserializeUncompressed = 47,
+    // Cost of serializing a BLS12-381 G2 point (Affine) into uncompressed form
+    Bls12381G2AffineSerializeUncompressed = 48,
+    // Cost of deserializing a BLS12-381 field element (Fp) from uncompressed form
+    Bls12381FpDeserializeUncompressed = 49,
+    // Cost of deserializing a BLS12-381 field element (Fp2) from uncompressed form
+    Bls12381Fp2DeserializeUncompressed = 50,
+    // Cost of serializing a BLS12-381 field element (Fp12)
+    Bls12381Fp12Serialize = 51,
+    // Cost of converting a BLS12-381 G1 point from projective to affine coordinates
+    Bls12381G1ProjectiveToAffine = 52,
+    // Cost of converting a BLS12-381 G2 point from projective to affine coordinates
+    Bls12381G2ProjectiveToAffine = 53,
+    // Cost of performing BLS12-381 G1 point addition
+    Bls12381G1Add = 54,
+    // Cost of performing BLS12-381 G1 scalar multiplication
+    Bls12381G1Mul = 55,
+    // Cost of performing BLS12-381 G1 multi-scalar multiplication (MSM)
+    Bls12381G1Msm = 56,
+    // Cost of mapping a BLS12-381 Fp field element to a G1 point
+    Bls12381MapFpToG1 = 57,
+    // Cost of hashing to a BLS12-381 G1 point
+    Bls12381HashToG1 = 58,
+    // Cost of performing BLS12-381 G2 point addition
+    Bls12381G2Add = 59,
+    // Cost of performing BLS12-381 G2 scalar multiplication
+    Bls12381G2Mul = 60,
+    // Cost of performing BLS12-381 G2 multi-scalar multiplication (MSM)
+    Bls12381G2Msm = 61,
+    // Cost of mapping a BLS12-381 Fp2 field element to a G2 point
+    Bls12381MapFp2ToG2 = 62,
+    // Cost of hashing to a BLS12-381 G2 point
+    Bls12381HashToG2 = 63,
+    // Cost of performing BLS12-381 pairing operation
+    Bls12381Pairing = 64
 };

```
### Semantics

#### Terminologies
`G1` - curve over base prime field. A point `p` in `G1` is represented with 96 bytes that is concatenation of the two coordinates `p.x || p.y`, each coordinate represented by a byte-serialized field element in the base prime field. 
`G2` - curve over quadratic extension of the base prime field. A point `p` in `G2` is represented with 192 bytes that is concatenation of the two coordinates `p.x || p.y`, each coordinate represented by a byte-serialized field element in the quadratic extension field. 
`fp` - field element in the base field. 
`fp2`- field element in the quadratic extension of the base prime field
`fp12` - field element in the 12-degree prime extension field. This is the output from the pairing operation.
`fr` - scalar. A scalar is represented with a 32 bytes `U256Object`. 

#### New host functions introduced

- `bls12_381_g1_add` - perform point addition in G1. Cost: covers the cost of de-serializing G1 points `Bls12381G1AffineDeserializeUncompressed`, conversion of G1 point from projective to affine space `Bls12381G1ProjectiveToAffine` , point addition `Bls12381G1Add` and deserializing the resulting `G1` point `Bls12381G1AffineSerializeUncompressed`. 
- `bls12_381_g1_mul` - perform scalar multiplication in G1. Cost: includes G1 point de-serialization, scalar deserialization, point multiplication `Bls12381G1Mul`, converting the point from project to affine and serialization
- `bls12_381_g1_msm` - perform multi-scalar-multiplication (MSM) in G1. Cost: includes deserialization of the G1 vector, the scalar vector, and the MSM operation `Bls12381G1Msm`, and serialization of the resulting G1 point. Errors: if the two vectors have different lengths, or the length is zero.
- `bls12_381_map_fp_to_g1` - maps an `fp` to a point in `G1`. Cost includes deserialization of the G1 point, the mapping cost `Bls12381MapFpToG1`, and serialization of the resulting G1 point.
- `bls12_381_hash_to_g1` - hashes an message (a sequence of bytes) into a point in `G1`. Cost is covered by `Bls12381HashToG1`. The domain separation tag (dst) is "Soroban-V00-CS00-with-BLS12381G1_XMD:SHA-256_SSWU_RO_".

- `bls12_381_g2_add` - perform point addition in G2. Cost: covers the cost of de-serializing G2 points `Bls12381G2AffineDeserializeUncompressed`, conversion of G2 point from projective to affine space `Bls12381G2ProjectiveToAffine` , point addition `Bls12381G2Add` and deserializing the resulting `G2` point `Bls12381G2AffineSerializeUncompressed`. 
- `bls12_381_g2_mul` - perform scalar multiplication in G2. Cost: includes G2 point de-serialization, scalar deserialization, point multiplication `Bls12381G2Mul`, converting the point from project to affine and serialization
- `bls12_381_g2_msm` - multi-scalar-multiplication (MSM) in G2. The cost includes deserialization of the G2 vector, the scalar vector, and the MSM operation `Bls12381G2Msm`, and serialization of the resulting G2 point. Errors: if the two vectors have different lengths, or the length is zero.
- `bls12_381_map_fp2_to_g2` - maps an `fp2` to a point in `G2`. Cost includes deserialization of the G2 point, the mapping cost `Bls12381MapFpToG2`, and serialization of the resulting G2 point.
- `bls12_381_hash_to_g2` - hashes an message (a sequence of bytes) into a point in `G2`. Cost is covered by `Bls12381HashToG2`. The domain separation tag (dst) is "Soroban-V00-CS00-with-BLS12381G2_XMD:SHA-256_SSWU_RO_".

- `bls12_381_pairing` - performs pairing between a point in `G1` and a point in `G2`. Cost includes deserialization of the two points (in G1 and G2 respectively), cost of pairing `Bls12381Pairing` and the cost of serializing the result `Bls12381Fp12Serialize`.

#### New `CostType`s introduced
- `Bls12381G1AffineDeserializeUncompressed` - Cost of deserializing an uncompressed BLS12-381 G1 point (Affine). Type: constant.
- `Bls12381G1AffineSerializeUncompressed` - Cost of serializing a BLS12-381 G1 point (Affine) into uncompressed form. Type: constant.
- `Bls12381G2AffineDeserializeUncompressed` - Cost of deserializing an uncompressed BLS12-381 G2 point (Affine). Type: constant.
- `Bls12381G2AffineSerializeUncompressed` - Cost of serializing a BLS12-381 G2 point (Affine) into uncompressed form. Type: constant.
- `Bls12381FpDeserializeUncompressed` - Cost of deserializing a BLS12-381 field element (Fp) from uncompressed form. Type: constant.
- `Bls12381Fp2DeserializeUncompressed` - Cost of deserializing a BLS12-381 field element (Fp2) from uncompressed form. Type: constant.
- `Bls12381Fp12Serialize` - Cost of serializing a BLS12-381 field element (Fp12). Type: constant.
- `Bls12381G1ProjectiveToAffine` - Cost of converting a BLS12-381 G1 point from projective to affine coordinates. Type: constant.
- `Bls12381G2ProjectiveToAffine` - Cost of converting a BLS12-381 G2 point from projective to affine coordinates. Type: constant.
- `Bls12381G1Add` - Cost of performing BLS12-381 G1 point addition. Type: constant.
- `Bls12381G1Mul` - Cost of performing BLS12-381 G1 scalar multiplication. Type: constant.
- `Bls12381G1Msm` - Cost of performing BLS12-381 G1 multi-scalar multiplication (MSM). Type: linear w.r.t the length of the input vectors. 
- `Bls12381MapFpToG1` - Cost of mapping a BLS12-381 Fp field element to a G1 point. Type: constant.
- `Bls12381HashToG1` - Cost of hashing to a BLS12-381 G1 point. Type: constant.
- `Bls12381G2Add` - Cost of performing BLS12-381 G2 point addition. Type: constant.
- `Bls12381G2Mul` - Cost of performing BLS12-381 G2 scalar multiplication. Type: constant.
- `Bls12381G2Msm` - Cost of performing BLS12-381 G2 multi-scalar multiplication (MSM). Type: linear w.r.t the length of the input vectors. 
- `Bls12381MapFp2ToG2` - Cost of mapping a BLS12-381 Fp2 field element to a G2 point. Type: constant.
- `Bls12381HashToG2` - Cost of hashing to a BLS12-381 G2 point. Type: constant.
- `Bls12381Pairing` - Cost of performing BLS12-381 pairing operation. Type: constant.

## Design Rationale

The list of host functions follows closely to what has been adopted by other chains, such as [eip-2537](https://eips.ethereum.org/EIPS/eip-2537). The proposed list includes two additional functions which performs hashing arbitrary message to curve points: `bls12_381_hash_to_g1` and `bls12_381_hash_to_g2`, which follow the IETF hash-to-curve standard as specified in [rfc9380](https://datatracker.ietf.org/doc/rfc9380/). 

## Protocol Upgrade Transition
The proposed host functions will become available protocol 22, i.e. with `"min_supported_protocol": 22` in the interface definition. For `protocol_version <= 21`, attempting to import any of these function definitions in the WASM will lead to a linking error during Vm instantiation time. 

### Backwards Incompatibilities
This CAP does not introduce any backward incompatibilities.

### Resource Utilization
The performance impact of the new host functions have been captured by the new `CostType` described above. The cpu and memory consumption need to be calibrated carefully on each new `CostType` to ensure that the cost of running BLS host functions are metered properly and subject to the network limits. Final calibration numbers are TBD.

## Security Concerns
The main security concerns include
- Logic correctness. The proposed set of functions cover a wide range of cryptographic operations, which rely on correctness of 3rd party implementations. Incorrect implementation or failure to cover certain corner case potentially be exploitable vulnerabilities. 
- Denial of service. Since the proposed operations are computationally intensive, failure to properly calibrate any part, or to properly account for an extra-expensive path, could lead to the actual computation time significantly exceeding the metered costs, thus potentially lead to denial of service. 

## Test Cases
TBD

## Implementation

An initial prototype of BLS12-381 host functions, SDK, and an example custom account contract with BLS signature has been implemented: 
- env-prototype: https://github.com/jayz22/rs-soroban-env/tree/bls12-318-field-arithmetic
- sdk-prototype (linking to the env prototype above): https://github.com/jayz22/rs-soroban-sdk/tree/bls12-318-field-arithmetic
- BLS-signature custom account example: https://github.com/jayz22/soroban-examples/tree/bls-signature/bls_signature
